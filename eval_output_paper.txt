#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
========================================
åŸºäºé¢„è®­ç»ƒæƒé‡çš„3Dæ‰“å°è´¨é‡è¯„ä¼°
========================================

åŠŸèƒ½:
1. åŠ è½½å·²è®­ç»ƒçš„ç¥ç»ç½‘ç»œæƒé‡
2. ç”ŸæˆçœŸå®ç‰©ç†ä»¿çœŸæ•°æ®
3. è¿›è¡ŒçœŸå®æ¨ç†
4. è¯„ä¼°å’Œå¯è§†åŒ–æ•ˆæœ

æƒé‡æ–‡ä»¶è·¯å¾„:
    - ./checkpoints_physical_predictor/best_physical_predictor.pth
    - ./checkpoints_fault_classifier/best_fault_classifier.pth
    - ./checkpoints_correction_controller/best_correction_controller.pth

ä½¿ç”¨æ–¹æ³•:
    python pretrained_nn_evaluation.py

è¾“å‡º:
    - pretrained_nn_results.png       (è¯„ä¼°ç»“æœå›¾)
    - pretrained_evaluation_report.txt (è¯„ä¼°æŠ¥å‘Š)
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import warnings
from datetime import datetime
from tqdm import tqdm
import pickle
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import sys

warnings.filterwarnings('ignore')

# è®¾ç½®ä¸­æ–‡å­—ä½“
plt.rcParams['font.sans-serif'] = ['SimHei', 'DejaVu Sans', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

# è®¾å¤‡é…ç½®
DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
print(f"ä½¿ç”¨è®¾å¤‡: {DEVICE}")

# ==================== çœŸå®æ•°æ®ç”Ÿæˆæ¨¡å— ====================
class Real3DPrintingSimulator:
    """
    åŸºäºdata_perpare.mçš„çœŸå®3Dæ‰“å°ä»¿çœŸå™¨
    åŒ…å«ç‰©ç†æ¨¡å‹ï¼šæŒ¯åŠ¨ã€æ¸©åº¦ã€æ•…éšœ
    """
    
    def __init__(self, n_machines=25, n_samples=5000, dt=0.001):
        self.n_machines = n_machines
        self.n_samples = n_samples
        self.dt = dt
        self.time = np.linspace(0, n_samples * dt, n_samples)
        
        # ç‰©ç†å‚æ•°ï¼ˆåŸºäºdata_perpare.mï¼‰
        self._init_physical_parameters()
        
    def _init_physical_parameters(self):
        """åˆå§‹åŒ–ç‰©ç†å‚æ•°"""
        np.random.seed(42)  # ç¡®ä¿å¯é‡å¤æ€§
        
        # çƒ­åŠ›æ¨¡å‹
        self.T_ambient = 22 + 1.5 * np.random.randn(self.n_machines)
        self.T_target = 215 + 2 * np.random.randn(self.n_machines)
        self.mass = 0.035 + 0.003 * np.random.randn(self.n_machines)
        self.specific_heat = 1750 + 80 * np.random.randn(self.n_machines)
        self.convection_coeff = 16 + 1.5 * np.random.randn(self.n_machines)
        self.heater_power_base = 32 + 2 * np.random.randn(self.n_machines)
        
        # æŒ¯åŠ¨æ¨¡å‹
        self.vib_mass = 0.45 + 0.05 * np.random.randn(self.n_machines)
        self.stiffness_x = 800 + 150 * np.random.randn(self.n_machines)
        self.stiffness_y = 750 + 120 * np.random.randn(self.n_machines)
        self.damping_x = 0.24 + 0.04 * np.random.randn(self.n_machines)
        self.damping_y = 0.21 + 0.035 * np.random.randn(self.n_machines)
        
        # ç”µæœºæ¨¡å‹
        self.rated_current = 2.0 + 0.2 * np.random.randn(self.n_machines)
        self.motor_resistance = 1.25 + 0.08 * np.random.randn(self.n_machines)
        self.back_emf_constant = 0.035 + 0.003 * np.random.randn(self.n_machines)
        
    def generate_gear_path(self):
        """ç”Ÿæˆé½¿è½®æ‰“å°è·¯å¾„"""
        from scipy import signal
        
        t_path = np.linspace(0, 2*np.pi, self.n_samples)
        gear_radius = 10
        teeth = 16
        
        # åŸºç¡€è½®å»“
        tooth_profile = gear_radius * (1 + 0.08 * np.sin(teeth * t_path))
        
        # è·¯å¾„
        x_path = tooth_profile * np.cos(t_path)
        y_path = tooth_profile * np.sin(t_path)
        z_path = np.linspace(0, 6, self.n_samples)  # 30å±‚ï¼Œæ¯å±‚0.2mm
        
        # ç†æƒ³è·¯å¾„ï¼ˆä½é€šæ»¤æ³¢ï¼‰
        b, a = signal.butter(2, 0.1)
        x_ideal = signal.filtfilt(b, a, x_path)
        y_ideal = signal.filtfilt(b, a, y_path)
        
        return x_path, y_path, z_path, x_ideal, y_ideal
    
    def simulate(self):
        """è¿è¡Œå®Œæ•´ä»¿çœŸ"""
        print("\nå¼€å§‹ç‰©ç†ä»¿çœŸ...")
        
        # ç”Ÿæˆè·¯å¾„
        x_path, y_path, z_path, x_ideal, y_ideal = self.generate_gear_path()
        
        # åˆå§‹åŒ–è¾“å‡ºæ•°ç»„
        temperature = np.zeros((self.n_samples, self.n_machines))
        vibration_x = np.zeros((self.n_samples, self.n_machines))
        vibration_y = np.zeros((self.n_samples, self.n_machines))
        vibration_vel_x = np.zeros((self.n_samples, self.n_machines))  # æ–°å¢æŒ¯åŠ¨é€Ÿåº¦
        vibration_vel_y = np.zeros((self.n_samples, self.n_machines))  # æ–°å¢æŒ¯åŠ¨é€Ÿåº¦
        motor_current_x = np.zeros((self.n_samples, self.n_machines))
        motor_current_y = np.zeros((self.n_samples, self.n_machines))
        nozzle_x = np.zeros((self.n_samples, self.n_machines))
        nozzle_y = np.zeros((self.n_samples, self.n_machines))
        pressure = np.zeros((self.n_samples, self.n_machines))
        fault_labels = np.zeros((self.n_samples, self.n_machines), dtype=int)
        
        # åˆå§‹æ¡ä»¶
        temperature[0, :] = self.T_ambient
        vibration_x[0, :] = 0.0005 * np.random.randn(self.n_machines)
        vibration_y[0, :] = 0.0005 * np.random.randn(self.n_machines)
        vibration_vel_x[0, :] = 0  # æ–°å¢æŒ¯åŠ¨é€Ÿåº¦åˆå§‹æ¡ä»¶
        vibration_vel_y[0, :] = 0  # æ–°å¢æŒ¯åŠ¨é€Ÿåº¦åˆå§‹æ¡ä»¶
        nozzle_x[0, :] = x_path[0]
        nozzle_y[0, :] = y_path[0]
        
        # è®¾ç½®æ•…éšœ
        np.random.seed(42)
        faulty_machines = np.random.choice(self.n_machines, 5, replace=False)
        fault_start_step = int(0.4 * self.n_samples)
        
        # ä¸»ä»¿çœŸå¾ªç¯
        print(f"  ä»¿çœŸæ­¥æ•°: {self.n_samples}")
        for t in tqdm(range(1, self.n_samples), desc="  ä»¿çœŸè¿›åº¦"):
            
            for mid in range(self.n_machines):
                # æ£€æŸ¥æ•…éšœ
                is_faulty = mid in faulty_machines and t > fault_start_step
                fault_type = faulty_machines.tolist().index(mid) % 3 + 1 if is_faulty else 0
                fault_labels[t, mid] = fault_type
                
                # ========= æ¸©åº¦æ¨¡å‹ =========
                temp_error = self.T_target[mid] - temperature[t-1, mid]
                heater_power = self.heater_power_base[mid] * (1 + 0.5 * np.tanh(temp_error))
                
                # æ•…éšœå½±å“
                if is_faulty and fault_type == 3:  # ä¼ æ„Ÿå™¨æ•…éšœ
                    measured_temp = temperature[t-1, mid] * (0.85 + 0.1 * np.random.random())
                else:
                    measured_temp = temperature[t-1, mid]
                
                heat_loss = self.convection_coeff[mid] * (measured_temp - self.T_ambient[mid])
                dTdt = (heater_power - heat_loss) / (self.mass[mid] * self.specific_heat[mid])
                temperature[t, mid] = temperature[t-1, mid] + dTdt * self.dt
                
                # æ·»åŠ æ¸©åº¦é™åˆ¶ï¼Œé˜²æ­¢æ•°å€¼ä¸ç¨³å®š
                temperature[t, mid] = np.clip(temperature[t, mid], 0, 300)
                
                # ========= æŒ¯åŠ¨æ¨¡å‹ =========
                pos_error_x = x_path[t] - nozzle_x[t-1, mid] - vibration_x[t-1, mid]
                pos_error_y = y_path[t] - nozzle_y[t-1, mid] - vibration_y[t-1, mid]
                
                # æ•…éšœå½±å“
                if is_faulty and fault_type == 2:  # æœºæ¢°æ•…éšœ
                    kx = self.stiffness_x[mid] * 0.6
                    ky = self.stiffness_y[mid] * 0.6
                    cx = self.damping_x[mid] * 0.7
                    cy = self.damping_y[mid] * 0.7
                else:
                    kx = self.stiffness_x[mid]
                    ky = self.stiffness_y[mid]
                    cx = self.damping_x[mid]
                    cy = self.damping_y[mid]
                
                # è®¡ç®—åŠ é€Ÿåº¦
                if t > 1:
                    vib_vel_x = (vibration_x[t-1, mid] - vibration_x[t-2, mid]) / self.dt
                    vib_vel_y = (vibration_y[t-1, mid] - vibration_y[t-2, mid]) / self.dt
                else:
                    vib_vel_x = 0
                    vib_vel_y = 0
                
                accel_x = (kx * pos_error_x - cx * vib_vel_x) / self.vib_mass[mid]
                accel_y = (ky * pos_error_y - cy * vib_vel_y) / self.vib_mass[mid]
                
                # æ›´æ–°æŒ¯åŠ¨é€Ÿåº¦ï¼ˆä½¿ç”¨é€Ÿåº¦Verletç®—æ³•ï¼‰
                if t > 0:
                    vibration_vel_x[t, mid] = vib_vel_x + accel_x * self.dt
                    vibration_vel_y[t, mid] = vib_vel_y + accel_y * self.dt
                else:
                    vibration_vel_x[t, mid] = 0
                    vibration_vel_y[t, mid] = 0
                
                # æ›´æ–°æŒ¯åŠ¨
                vibration_x[t, mid] = vibration_x[t-1, mid] + accel_x * self.dt
                vibration_y[t, mid] = vibration_y[t-1, mid] + accel_y * self.dt
                
                # æ·»åŠ æŒ¯åŠ¨é™åˆ¶ï¼Œé˜²æ­¢æ•°å€¼ä¸ç¨³å®š
                vibration_x[t, mid] = np.clip(vibration_x[t, mid], -0.01, 0.01)
                vibration_y[t, mid] = np.clip(vibration_y[t, mid], -0.01, 0.01)
                
                # ========= å–·å¤´ä½ç½® =========
                nozzle_x[t, mid] = x_path[t] + vibration_x[t, mid]
                nozzle_y[t, mid] = y_path[t] + vibration_y[t, mid]
                
                # ========= ç”µæœºç”µæµ =========
                movement_speed = np.sqrt(pos_error_x**2 + pos_error_y**2) / self.dt
                # é™åˆ¶é€Ÿåº¦ï¼Œé˜²æ­¢æ•°å€¼è¿‡å¤§
                movement_speed = np.clip(movement_speed, 0, 100)
                motor_factor = 0.7 if is_faulty and fault_type == 3 else 1.0
                motor_current_x[t, mid] = self.rated_current[mid] * (1 + 0.2 * movement_speed / 50) * motor_factor
                motor_current_y[t, mid] = self.rated_current[mid] * (1 + 0.2 * movement_speed / 50) * motor_factor
                
                # é™åˆ¶ç”µæµå€¼ï¼Œé˜²æ­¢æ•°å€¼ä¸ç¨³å®š
                motor_current_x[t, mid] = np.clip(motor_current_x[t, mid], 0, 5)
                motor_current_y[t, mid] = np.clip(motor_current_y[t, mid], 0, 5)
                
                # ========= æŒ¤å‡ºå‹åŠ› =========
                pressure_multiplier = 1.8 + 0.4 * np.random.random() if is_faulty and fault_type == 1 else 1.0
                speed_factor = min(1, movement_speed / 80)
                temp_factor = (temperature[t, mid] - 180) / 50
                pressure[t, mid] = 4.5 * pressure_multiplier * (0.6 + 0.25 * speed_factor + 0.15 * temp_factor)
                
                # é™åˆ¶å‹åŠ›å€¼ï¼Œé˜²æ­¢æ•°å€¼ä¸ç¨³å®š
                pressure[t, mid] = np.clip(pressure[t, mid], 0, 20)
        
        print("  ä»¿çœŸå®Œæˆï¼")
        
        # åˆ›å»ºDataFrame
        data_list = []
        for t in range(self.n_samples):
            for mid in range(self.n_machines):
                data_list.append({
                    'time': self.time[t],
                    'machine_id': mid,
                    'ctrl_T_target': self.T_target[mid],
                    'ctrl_speed_set': 50.0,
                    'ctrl_pos_x': x_path[t],
                    'ctrl_pos_y': y_path[t],
                    'ctrl_pos_z': z_path[t],
                    'temperature_C': temperature[t, mid],
                    'vibration_disp_x_m': vibration_x[t, mid],
                    'vibration_disp_y_m': vibration_y[t, mid],
                    'vibration_vel_x_m_s': vibration_vel_x[t, mid],  # æ·»åŠ æŒ¯åŠ¨é€Ÿåº¦
                    'vibration_vel_y_m_s': vibration_vel_y[t, mid],  # æ·»åŠ æŒ¯åŠ¨é€Ÿåº¦
                    'motor_current_x_A': motor_current_x[t, mid],
                    'motor_current_y_A': motor_current_y[t, mid],
                    'pressure_bar': pressure[t, mid],
                    'fault_label': fault_labels[t, mid],
                    'x_ideal': x_ideal[t],
                    'y_ideal': y_ideal[t]
                })
        
        df = pd.DataFrame(data_list)
        print(f"  æ•°æ®ç‚¹æ€»æ•°: {len(df)}")
        
        return df

# ==================== ç¥ç»ç½‘ç»œæ¨¡å‹å®šä¹‰ï¼ˆå¿…é¡»ä¸è®­ç»ƒæ—¶ä¸€è‡´ï¼‰ ====================

# 1. ç‰©ç†é¢„æµ‹æ¨¡å‹ (åŸºäºtrain_physical_predictor.py)
class PhysicalPredictor(nn.Module):
    def __init__(self, input_dim=13, model_dim=192, output_dim=5):  # ä¿®æ”¹ä¸º13ç»´è¾“å…¥ï¼ŒåªåŒ…å«æ—¶åŸŸç‰¹å¾
        super(PhysicalPredictor, self).__init__()
        
        # è¾“å…¥ç»´åº¦æ˜ å°„
        self.input_projection = nn.Linear(input_dim, model_dim)
        
        # ä½ç½®ç¼–ç 
        self.pos_encoder = nn.Parameter(torch.randn(1, 251, model_dim))  # seq_len=250 + cls
        
        # ç¼–ç å™¨
        encoder_layer = nn.TransformerEncoderLayer(
            d_model=model_dim,
            nhead=8,
            dim_feedforward=768,
            dropout=0.1,
            batch_first=True,
            norm_first=True
        )
        self.encoder = nn.TransformerEncoder(encoder_layer, num_layers=5)
        
        # å¤šå¤´è¾“å‡º
        self.vibration_head = nn.Sequential(
            nn.Linear(model_dim, 96),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(96, 2)
        )
        
        self.thermal_head = nn.Sequential(
            nn.Linear(model_dim, 64),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(64, 1)
        )
        
        self.motor_head = nn.Sequential(
            nn.Linear(model_dim, 64),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(64, 2)
        )
    
    def forward(self, x):
        """
        x: [batch, input_dim] for single step or [batch, seq_len, input_dim] for sequences
        """
        # æ£€æŸ¥è¾“å…¥ç»´åº¦ï¼Œå¦‚æœæ˜¯äºŒç»´åˆ™æ‰©å±•ä¸ºä¸‰ç»´ï¼ˆå•æ­¥åºåˆ—ï¼‰
        if len(x.shape) == 2:
            x = x.unsqueeze(1)  # [batch, 1, input_dim]
        
        # æŠ•å½±è¾“å…¥åˆ°model_dim
        x = self.input_projection(x)  # [batch, seq_len, model_dim]
        
        # æ·»åŠ CLS token
        batch_size = x.size(0)
        cls_token = torch.zeros(batch_size, 1, x.size(2)).to(x.device)
        x = torch.cat([cls_token, x], dim=1)  # [batch, seq_len+1, model_dim]
        
        # ç®€å•ç¼–ç ï¼ˆå®é™…åº”è¯¥æ›´å¤æ‚ï¼‰
        memory = self.encoder(x)  # [batch, seq_len+1, model_dim]
        
        # ä½¿ç”¨CLS token
        cls_output = memory[:, 0, :]  # [batch, model_dim]
        
        # å¤šå¤´é¢„æµ‹
        vib_pred = self.vibration_head(cls_output)
        temp_pred = self.thermal_head(cls_output)
        motor_pred = self.motor_head(cls_output)
        
        return torch.cat([vib_pred, temp_pred, motor_pred], dim=1)  # [batch, 5]

# 2. æ•…éšœåˆ†ç±»å™¨ (åŸºäºtrain_fault_classifier.py)
class FaultClassifier(nn.Module):
    def __init__(self, input_dim=8, model_dim=128, n_classes=4):
        super(FaultClassifier, self).__init__()
        
        self.embedding = nn.Linear(input_dim, model_dim)
        
        encoder_layer = nn.TransformerEncoderLayer(
            d_model=model_dim,
            nhead=8,
            dim_feedforward=512,
            dropout=0.1,
            batch_first=True
        )
        self.encoder = nn.TransformerEncoder(encoder_layer, num_layers=3)
        
        self.classifier = nn.Sequential(
            nn.Linear(model_dim, 64),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(64, n_classes)
        )
    
    def forward(self, x):
        """
        x: [batch, seq_len, input_dim] for sequences or [batch, input_dim] for single step
        """
        # æ£€æŸ¥è¾“å…¥ç»´åº¦ï¼Œå¦‚æœæ˜¯äºŒç»´åˆ™æ‰©å±•ä¸ºä¸‰ç»´ï¼ˆå•æ­¥åºåˆ—ï¼‰
        if len(x.shape) == 2:
            x = x.unsqueeze(1)  # [batch, 1, input_dim]
        
        x = self.embedding(x)  # [batch, seq_len, model_dim]
        memory = self.encoder(x)  # [batch, seq_len, model_dim]
        
        # ä½¿ç”¨åºåˆ—æ‰€æœ‰æ—¶é—´æ­¥çš„å¹³å‡å€¼
        seq_avg = torch.mean(memory, dim=1)  # [batch, model_dim]
        
        return self.classifier(seq_avg)

# 3. çŸ«æ­£æ§åˆ¶å™¨ (åŸºäºtrain_correction_controller.py)
class CorrectionController(nn.Module):
    def __init__(self, input_dim=13, hidden_dim=128, output_dim=3):
        super(CorrectionController, self).__init__()
        
        self.net = nn.Sequential(
            nn.Linear(input_dim, hidden_dim),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(hidden_dim, 64),
            nn.ReLU(),
            nn.Linear(64, output_dim)
        )
    
    def forward(self, x):
        return self.net(x)

# ==================== æ•°æ®é›†ç±» ====================
class PrintDataset(Dataset):
    def __init__(self, data, feature_cols, target_cols=None, mode='predict', seq_len=None):
        self.data = data[feature_cols].values
        self.mode = mode
        self.seq_len = seq_len
        
        if target_cols and mode in ['predict', 'correct']:
            self.targets = data[target_cols].values
        elif mode == 'classify':
            self.targets = data['fault_label'].values
        else:
            self.targets = None
            
    def __len__(self):
        return len(self.data)
    
    def __getitem__(self, idx):
        features = torch.FloatTensor(self.data[idx])
        
        if self.mode == 'classify':
            label = int(self.targets[idx])
            return features, label
        elif self.targets is not None:
            target = torch.FloatTensor(self.targets[idx])
            return features, target
        else:
            return features, features

# ==================== åŠ è½½é¢„è®­ç»ƒæ¨¡å‹ ====================
def load_pretrained_models():
    """åŠ è½½é¢„è®­ç»ƒçš„æ¨¡å‹"""
    print("\nåŠ è½½é¢„è®­ç»ƒæ¨¡å‹...")
    
    models = {}
    
    # 1. ç‰©ç†é¢„æµ‹æ¨¡å‹
    print("  [1/3] åŠ è½½ç‰©ç†é¢„æµ‹æ¨¡å‹...")
    physical_model_path = './checkpoints_physical_predictor/best_physical_predictor.pth'

    try:
        checkpoint = torch.load(physical_model_path, map_location=DEVICE)

        # è·å–é…ç½®
        if 'config' in checkpoint:
            config = checkpoint['config']
            input_dim = config.get('input_dim', 13)  # ä¿®æ”¹é»˜è®¤å€¼ä¸º13
        else:
            input_dim = 13  # ä¿®æ”¹é»˜è®¤å€¼ä¸º13

        physical_model = PhysicalPredictor(input_dim=input_dim)
        
        # åŠ è½½æƒé‡
        if 'model_state_dict' in checkpoint:
            state_dict = checkpoint['model_state_dict']
            # å¤„ç†DataParallelåŒ…è£…çš„æƒé‡
            new_state_dict = {}
            for k, v in state_dict.items():
                if k.startswith('module.'):
                    new_state_dict[k[7:]] = v
                else:
                    new_state_dict[k] = v
            physical_model.load_state_dict(new_state_dict, strict=False)
        
        physical_model = physical_model.to(DEVICE)
        physical_model.eval()
        models['physical'] = physical_model
        print(f"    âœ“ ç‰©ç†é¢„æµ‹æ¨¡å‹åŠ è½½æˆåŠŸ (å‚æ•°é‡: {sum(p.numel() for p in physical_model.parameters())})")
        
    except Exception as e:
        print(f"    âœ— ç‰©ç†é¢„æµ‹æ¨¡å‹åŠ è½½å¤±è´¥: {e}")
        print(f"    å°è¯•åˆ›å»ºæ–°æ¨¡å‹...")
        physical_model = PhysicalPredictor(input_dim=13).to(DEVICE)  # ä¿®æ”¹ä¸º13ç»´è¾“å…¥
        physical_model.eval()
        models['physical'] = physical_model
    
    # 2. æ•…éšœåˆ†ç±»å™¨
    print("  [2/3] åŠ è½½æ•…éšœåˆ†ç±»å™¨...")
    fault_model_path = './checkpoints_fault_classifier/best_fault_classifier.pth'
    
    try:
        checkpoint = torch.load(fault_model_path, map_location=DEVICE)
        
        fault_model = FaultClassifier(input_dim=8, n_classes=4)
        
        if 'model_state_dict' in checkpoint:
            state_dict = checkpoint['model_state_dict']
            new_state_dict = {}
            for k, v in state_dict.items():
                if k.startswith('module.'):
                    new_state_dict[k[7:]] = v
                else:
                    new_state_dict[k] = v
            fault_model.load_state_dict(new_state_dict, strict=False)
        
        fault_model = fault_model.to(DEVICE)
        fault_model.eval()
        models['fault'] = fault_model
        print(f"    âœ“ æ•…éšœåˆ†ç±»å™¨åŠ è½½æˆåŠŸ (å‚æ•°é‡: {sum(p.numel() for p in fault_model.parameters())})")
        
    except Exception as e:
        print(f"    âœ— æ•…éšœåˆ†ç±»å™¨åŠ è½½å¤±è´¥: {e}")
        print(f"    å°è¯•åˆ›å»ºæ–°æ¨¡å‹...")
        fault_model = FaultClassifier(input_dim=8, n_classes=4).to(DEVICE)  # ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„è¾“å…¥ç»´åº¦
        fault_model.eval()
        models['fault'] = fault_model
    
    # 3. çŸ«æ­£æ§åˆ¶å™¨
    print("  [3/3] åŠ è½½çŸ«æ­£æ§åˆ¶å™¨...")
    correction_model_path = './checkpoints_correction_controller/best_correction_controller.pth'
    
    try:
        checkpoint = torch.load(correction_model_path, map_location=DEVICE)
        
        if 'config' in checkpoint:
            config = checkpoint['config']
            input_dim = config.get('input_dim', 13)  # ä½¿ç”¨æ­£ç¡®çš„è¾“å…¥ç»´åº¦
        else:
            input_dim = 13  # ä½¿ç”¨æ­£ç¡®çš„è¾“å…¥ç»´åº¦
            
        correction_model = CorrectionController(input_dim=input_dim)
        
        if 'model_state_dict' in checkpoint:
            state_dict = checkpoint['model_state_dict']
            new_state_dict = {}
            for k, v in state_dict.items():
                if k.startswith('module.'):
                    new_state_dict[k[7:]] = v
                else:
                    new_state_dict[k] = v
            correction_model.load_state_dict(new_state_dict, strict=False)
        
        correction_model = correction_model.to(DEVICE)
        correction_model.eval()
        models['correction'] = correction_model
        print(f"    âœ“ çŸ«æ­£æ§åˆ¶å™¨åŠ è½½æˆåŠŸ (å‚æ•°é‡: {sum(p.numel() for p in correction_model.parameters())})")
        
    except Exception as e:
        print(f"    âœ— çŸ«æ­£æ§åˆ¶å™¨åŠ è½½å¤±è´¥: {e}")
        print(f"    å°è¯•åˆ›å»ºæ–°æ¨¡å‹...")
        correction_model = CorrectionController(input_dim=13).to(DEVICE)  # ä½¿ç”¨æ­£ç¡®çš„è¾“å…¥ç»´åº¦
        correction_model.eval()
        models['correction'] = correction_model

    # å°è¯•åŠ è½½æ ‡å‡†åŒ–å‚æ•°
    print("\nåŠ è½½æ ‡å‡†åŒ–å‚æ•°...")
    norm_params = {}
    
    try:
        with open('./checkpoints_physical_predictor/normalization_params.pkl', 'rb') as f:
            norm_params['physical'] = pickle.load(f)
        print("  âœ“ ç‰©ç†é¢„æµ‹æ¨¡å‹æ ‡å‡†åŒ–å‚æ•°åŠ è½½æˆåŠŸ")
    except:
        print("  âœ— ç‰©ç†é¢„æµ‹æ¨¡å‹æ ‡å‡†åŒ–å‚æ•°æœªæ‰¾åˆ°")
    
    try:
        with open('./checkpoints_correction_controller/correction_params.pkl', 'rb') as f:
            norm_params['correction'] = pickle.load(f)
        print("  âœ“ çŸ«æ­£æ§åˆ¶å™¨æ ‡å‡†åŒ–å‚æ•°åŠ è½½æˆåŠŸ")
    except:
        print("  âœ— çŸ«æ­£æ§åˆ¶å™¨æ ‡å‡†åŒ–å‚æ•°æœªæ‰¾åˆ°")
    
    return models, norm_params

# ==================== æ¨ç†å‡½æ•° ====================
def predict_with_model(model, data, mode='predict'):
    """ä½¿ç”¨æ¨¡å‹è¿›è¡Œæ¨ç†"""
    model.eval()
    predictions = []
    
    with torch.no_grad():
        # åˆ†æ‰¹å¤„ç†
        batch_size = 256
        for i in range(0, len(data), batch_size):
            batch = torch.FloatTensor(data[i:i+batch_size]).to(DEVICE)
            
            if mode in ['predict', 'correct']:
                outputs = model(batch)
                predictions.append(outputs.cpu().numpy())
            else:  # classify
                outputs = model(batch)
                pred = torch.argmax(outputs, dim=1)
                predictions.append(pred.cpu().numpy())
    
    return np.concatenate(predictions, axis=0)

# ==================== ä¸»è¯„ä¼°æµç¨‹ ====================
def main():
    print("=" * 80)
    print("åŸºäºé¢„è®­ç»ƒæƒé‡çš„3Dæ‰“å°è´¨é‡è¯„ä¼°")
    print("=" * 80)
    print(f"å¼€å§‹æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    # ==================== 1. ç”ŸæˆçœŸå®ä»¿çœŸæ•°æ® ====================
    print("\n[æ­¥éª¤ 1/5] ç”ŸæˆçœŸå®ç‰©ç†ä»¿çœŸæ•°æ®...")
    simulator = Real3DPrintingSimulator(n_machines=25, n_samples=5000, dt=0.001)
    df = simulator.simulate()
    
    # ==================== 2. å‡†å¤‡æ•°æ® ====================
    print("\n[æ­¥éª¤ 2/5] å‡†å¤‡æ•°æ®...")
    
    # å®šä¹‰ç‰¹å¾åˆ—
    predict_feature_cols = [
        'ctrl_T_target', 'ctrl_speed_set', 'ctrl_pos_x', 'ctrl_pos_y', 'ctrl_pos_z',
        'temperature_C', 'vibration_disp_x_m', 'vibration_disp_y_m',
        'vibration_vel_x_m_s', 'vibration_vel_y_m_s',  # æ·»åŠ ç¼ºå¤±çš„æŒ¯åŠ¨é€Ÿåº¦ç‰¹å¾
        'motor_current_x_A', 'motor_current_y_A', 'pressure_bar'
    ]
    predict_target_cols = [
        'vibration_disp_x_m', 'vibration_disp_y_m',
        'temperature_C', 'motor_current_x_A', 'motor_current_y_A'
    ]
    
    classify_feature_cols = [
        'temperature_C', 'vibration_disp_x_m', 'vibration_disp_y_m',
        'vibration_vel_x_m_s', 'vibration_vel_y_m_s',
        'motor_current_x_A', 'motor_current_y_A', 'pressure_bar'
    ]
    
    correct_feature_cols = predict_feature_cols
    
    # æ•°æ®æ ‡å‡†åŒ–
    predict_scaler_X = StandardScaler()
    predict_scaler_y = StandardScaler()
    classify_scaler_X = StandardScaler()
    correct_scaler_X = StandardScaler()
    correct_scaler_y = StandardScaler()
    
    df_scaled = df.copy()
    df_scaled[predict_feature_cols] = predict_scaler_X.fit_transform(df[predict_feature_cols])
    df_scaled[predict_target_cols] = predict_scaler_y.fit_transform(df[predict_target_cols])
    df_scaled[classify_feature_cols] = classify_scaler_X.fit_transform(df[classify_feature_cols])
    df_scaled[correct_feature_cols] = correct_scaler_X.fit_transform(df[correct_feature_cols])
    
    # åˆ›å»ºçŸ«æ­£ç›®æ ‡
    df['correction_x_mm'] = (df['x_ideal'] - df['ctrl_pos_x']) * 1000
    df['correction_y_mm'] = (df['y_ideal'] - df['ctrl_pos_y']) * 1000
    df['correction_temp_C'] = df['ctrl_T_target'] - df['temperature_C']
    correct_target_cols = ['correction_x_mm', 'correction_y_mm', 'correction_temp_C']
    df_scaled[correct_target_cols] = correct_scaler_y.fit_transform(df[correct_target_cols])
    
    # åˆ†å‰²æµ‹è¯•é›†
    test_df = df_scaled.sample(frac=0.2, random_state=42)
    print(f"  æµ‹è¯•é›†æ ·æœ¬æ•°: {len(test_df)}")
    
    # ==================== 3. åŠ è½½é¢„è®­ç»ƒæ¨¡å‹ ====================
    print("\n[æ­¥éª¤ 3/5] åŠ è½½é¢„è®­ç»ƒæ¨¡å‹...")
    models, norm_params = load_pretrained_models()
    
    # ==================== 4. æ¨ç† ====================
    print("\n[æ­¥éª¤ 4/5] è¿›è¡Œæ¨ç†...")
    
    # ç‰©ç†é¢„æµ‹æ¨ç†
    print("  [1/3] ç‰©ç†é¢„æµ‹æ¨ç†...")
    phys_pred = predict_with_model(models['physical'], 
                                     test_df[predict_feature_cols].values, 
                                     'predict')
    phys_target = test_df[predict_target_cols].values
    
    # æ•…éšœåˆ†ç±»æ¨ç†
    print("  [2/3] æ•…éšœåˆ†ç±»æ¨ç†...")
    fault_pred = predict_with_model(models['fault'], 
                                     test_df[classify_feature_cols].values, 
                                     'classify')
    fault_target = test_df['fault_label'].values
    
    # çŸ«æ­£æ§åˆ¶æ¨ç†
    print("  [3/3] çŸ«æ­£æ§åˆ¶æ¨ç†...")
    # åªå¯¹æ­£å¸¸æ•°æ®è¿›è¡ŒçŸ«æ­£
    normal_test_df = test_df[test_df['fault_label'] == 0]
    corr_pred = predict_with_model(models['correction'], 
                                   normal_test_df[correct_feature_cols].values, 
                                   'correct')
    corr_target = normal_test_df[correct_target_cols].values
    
    # ==================== 5. è¯„ä¼°å’Œåº”ç”¨ ====================
    print("\n[æ­¥éª¤ 5/5] è¯„ä¼°å’Œåº”ç”¨...")
    
    # ç‰©ç†é¢„æµ‹è¯„ä¼°
    phys_mae = np.mean(np.abs(phys_pred - phys_target), axis=0)
    phys_mae_labels = ['Vib X', 'Vib Y', 'Temp', 'Current X', 'Current Y']
    
    # æ•…éšœåˆ†ç±»è¯„ä¼°
    fault_accuracy = np.mean(fault_pred == fault_target)
    fault_report = classification_report(fault_target, fault_pred, output_dict=True, zero_division=0)
    fault_cm = confusion_matrix(fault_target, fault_pred)
    
    # çŸ«æ­£æ§åˆ¶è¯„ä¼°
    corr_mae = np.mean(np.abs(corr_pred - corr_target), axis=0)
    corr_mae_labels = ['Correction X', 'Correction Y', 'Correction Temp']
    
    # åº”ç”¨çŸ«æ­£
    print("  åº”ç”¨ç¥ç»ç½‘ç»œçŸ«æ­£...")
    normal_original_df = test_df[test_df['fault_label'] == 0].copy()
    
    # åæ ‡å‡†åŒ–
    corr_pred_original = correct_scaler_y.inverse_transform(corr_pred)
    
    # åº”ç”¨åˆ°åŸå§‹æ•°æ®
    corrected_results = []
    for idx in range(len(normal_original_df)):
        row_idx = normal_original_df.index[idx]
        row = df.loc[row_idx]
        correction = corr_pred_original[idx]
        
        # åº”ç”¨çŸ«æ­£
        corrected_x = row['ctrl_pos_x'] + correction[0] / 1000
        corrected_y = row['ctrl_pos_y'] + correction[1] / 1000
        corrected_temp = row['temperature_C'] + correction[2]
        
        corrected_results.append({
            'x_original': row['ctrl_pos_x'],
            'y_original': row['ctrl_pos_y'],
            'x_corrected': corrected_x,
            'y_corrected': corrected_y,
            'x_ideal': row['x_ideal'],
            'y_ideal': row['y_ideal'],
            'temp_original': row['temperature_C'],
            'temp_corrected': corrected_temp
        })
    
    corrected_df = pd.DataFrame(corrected_results)
    
    # è®¡ç®—è¯¯å·®
    original_error = np.sqrt((corrected_df['x_original'] - corrected_df['x_ideal'])**2 + 
                            (corrected_df['y_original'] - corrected_df['y_ideal'])**2)
    corrected_error = np.sqrt((corrected_df['x_corrected'] - corrected_df['x_ideal'])**2 + 
                             (corrected_df['y_corrected'] - corrected_df['y_ideal'])**2)
    
    print(f"\nğŸ“Š è¯„ä¼°ç»“æœ:")
    print(f"  ç‰©ç†é¢„æµ‹MAE: {dict(zip(phys_mae_labels, phys_mae))}")
    print(f"  æ•…éšœåˆ†ç±»å‡†ç¡®ç‡: {fault_accuracy:.4f}")
    print(f"  çŸ«æ­£æ§åˆ¶MAE: {dict(zip(corr_mae_labels, corr_mae))}")
    print(f"  ä½ç½®è¯¯å·®æ”¹è¿›: åŸå§‹ {original_error.mean():.6f} -> çŸ«æ­£å {corrected_error.mean():.6f}")
    
    # ==================== 6. å¯è§†åŒ– ====================
    print("\n[æ­¥éª¤ 6/6] ç”Ÿæˆå¯è§†åŒ–ç»“æœ...")
    
    # åˆ›å»ºç»“æœå›¾
    fig = plt.figure(figsize=(20, 15))
    gs = GridSpec(4, 4, figure=fig)
    
    # ç‰©ç†é¢„æµ‹ç»“æœ
    for i, label in enumerate(phys_mae_labels):
        ax = fig.add_subplot(gs[i//2, i%2])
        ax.scatter(phys_target[:500, i], phys_pred[:500, i], alpha=0.6, s=10)
        ax.plot([phys_target[:500, i].min(), phys_target[:500, i].max()], 
                [phys_target[:500, i].min(), phys_target[:500, i].max()], 'r--', lw=2)
        ax.set_xlabel('çœŸå®å€¼')
        ax.set_ylabel('é¢„æµ‹å€¼')
        ax.set_title(f'{label} - MAE: {phys_mae[i]:.4f}')
        ax.grid(True, alpha=0.3)
    
    # æ•…éšœåˆ†ç±»æ··æ·†çŸ©é˜µ
    ax = fig.add_subplot(gs[0, 2:])
    im = ax.imshow(fault_cm, interpolation='nearest', cmap=plt.cm.Blues)
    ax.figure.colorbar(im, ax=ax)
    ax.set(xticks=np.arange(fault_cm.shape[1]),
           yticks=np.arange(fault_cm.shape[0]),
           xticklabels=range(4), yticklabels=range(4),
           title='æ•…éšœåˆ†ç±»æ··æ·†çŸ©é˜µ')
    
    # æ·»åŠ æ··æ·†çŸ©é˜µæ•°å€¼
    thresh = fault_cm.max() / 2.
    for i in range(fault_cm.shape[0]):
        for j in range(fault_cm.shape[1]):
            ax.text(j, i, format(fault_cm[i, j], 'd'),
                    ha="center", va="center",
                    color="white" if fault_cm[i, j] > thresh else "black")
    
    # çŸ«æ­£æ•ˆæœ
    ax = fig.add_subplot(gs[1, 2:])
    ax.hist(original_error, bins=50, alpha=0.5, label='åŸå§‹è¯¯å·®', density=True)
    ax.hist(corrected_error, bins=50, alpha=0.5, label='çŸ«æ­£åè¯¯å·®', density=True)
    ax.set_xlabel('ä½ç½®è¯¯å·® (mm)')
    ax.set_ylabel('å¯†åº¦')
    ax.set_title('ä½ç½®è¯¯å·®åˆ†å¸ƒå¯¹æ¯”')
    ax.legend()
    ax.grid(True, alpha=0.3)
    
    # çŸ«æ­£å‰åè½¨è¿¹å¯¹æ¯”
    ax = fig.add_subplot(gs[2, :])
    ax.plot(corrected_df['x_ideal'][:1000], corrected_df['y_ideal'][:1000], 
            'g-', label='ç†æƒ³è½¨è¿¹', linewidth=2)
    ax.plot(corrected_df['x_original'][:1000], corrected_df['y_original'][:1000], 
            'r--', label='åŸå§‹è½¨è¿¹', alpha=0.7)
    ax.plot(corrected_df['x_corrected'][:1000], corrected_df['y_corrected'][:1000], 
            'b-', label='çŸ«æ­£è½¨è¿¹', alpha=0.7)
    ax.set_xlabel('X (mm)')
    ax.set_ylabel('Y (mm)')
    ax.set_title('è½¨è¿¹å¯¹æ¯” (å‰1000ä¸ªç‚¹)')
    ax.legend()
    ax.grid(True, alpha=0.3)
    
    # çŸ«æ­£å‰åè¯¯å·®å¯¹æ¯”
    ax = fig.add_subplot(gs[3, :])
    ax.plot(original_error.values[:2000], label='åŸå§‹è¯¯å·®', alpha=0.7)
    ax.plot(corrected_error.values[:2000], label='çŸ«æ­£åè¯¯å·®', alpha=0.7)
    ax.set_xlabel('æ ·æœ¬ç´¢å¼•')
    ax.set_ylabel('ä½ç½®è¯¯å·® (mm)')
    ax.set_title('è¯¯å·®å¯¹æ¯” (å‰2000ä¸ªç‚¹)')
    ax.legend()
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('pretrained_nn_results.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    # ==================== 7. ç”ŸæˆæŠ¥å‘Š ====================
    print("\n[æ­¥éª¤ 7/7] ç”Ÿæˆè¯„ä¼°æŠ¥å‘Š...")
    
    with open('pretrained_evaluation_report.txt', 'w', encoding='utf-8') as f:
        f.write("åŸºäºé¢„è®­ç»ƒæƒé‡çš„3Dæ‰“å°è´¨é‡è¯„ä¼°æŠ¥å‘Š\n")
        f.write("="*50 + "\n")
        f.write(f"è¯„ä¼°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        
        f.write("æ¨¡å‹é…ç½®:\n")
        f.write(f"  ç‰©ç†é¢„æµ‹æ¨¡å‹å‚æ•°: {sum(p.numel() for p in models['physical'].parameters())}\n")
        f.write(f"  æ•…éšœåˆ†ç±»å™¨å‚æ•°: {sum(p.numel() for p in models['fault'].parameters())}\n")
        f.write(f"  çŸ«æ­£æ§åˆ¶å™¨å‚æ•°: {sum(p.numel() for p in models['correction'].parameters())}\n\n")
        
        f.write("ç‰©ç†é¢„æµ‹ç»“æœ:\n")
        for label, mae in zip(phys_mae_labels, phys_mae):
            f.write(f"  {label}: MAE = {mae:.6f}\n")
        f.write("\n")
        
        f.write("æ•…éšœåˆ†ç±»ç»“æœ:\n")
        f.write(f"  å‡†ç¡®ç‡: {fault_accuracy:.6f}\n")
        f.write("  è¯¦ç»†åˆ†ç±»æŠ¥å‘Š:\n")
        f.write(classification_report(fault_target, fault_pred, zero_division=0))
        f.write("\n")
        
        f.write("çŸ«æ­£æ§åˆ¶ç»“æœ:\n")
        for label, mae in zip(corr_mae_labels, corr_mae):
            f.write(f"  {label}: MAE = {mae:.6f}\n")
        f.write("\n")
        
        f.write("è½¨è¿¹çŸ«æ­£æ•ˆæœ:\n")
        f.write(f"  å¹³å‡åŸå§‹è¯¯å·®: {original_error.mean():.6f} mm\n")
        f.write(f"  å¹³å‡çŸ«æ­£åè¯¯å·®: {corrected_error.mean():.6f} mm\n")
        f.write(f"  è¯¯å·®æ”¹è¿›ç‡: {(original_error.mean() - corrected_error.mean()) / original_error.mean() * 100:.2f}%\n")
    
    print("âœ… è¯„ä¼°å®Œæˆ!")
    print(f"  - ç»“æœå›¾: pretrained_nn_results.png")
    print(f"  - è¯„ä¼°æŠ¥å‘Š: pretrained_evaluation_report.txt")
    print(f"ç»“æŸæ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

if __name__ == "__main__":
    main()